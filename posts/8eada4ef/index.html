<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>XJTU-ICS Lab 2: Bomb Lab | 日拱一卒</title><meta name="author" content="Derrick Liu,1209830516abc@gmail.com"><meta name="copyright" content="Derrick Liu"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="前言 Bomb Lab是课程的第二个实验，它给出了一个“炸弹”文件，要求学习者从可执行文件反汇编得到汇编代码，然后通过GDB（GNU Debugger）来知晓“炸弹”的引爆逻辑，并由此给出正确的解决文件solution.txt，正确地拆除全部phase的炸弹。如果成功独立完成了这个实验，相信你对GDB的使用和x86-64汇编语言的理解会上一个台阶。 实验文档与代码框架 实验文档请点击此链接查看。每">
<meta property="og:type" content="article">
<meta property="og:title" content="XJTU-ICS Lab 2: Bomb Lab">
<meta property="og:url" content="https://ziyuliu258.github.io/posts/8eada4ef/index.html">
<meta property="og:site_name" content="日拱一卒">
<meta property="og:description" content="前言 Bomb Lab是课程的第二个实验，它给出了一个“炸弹”文件，要求学习者从可执行文件反汇编得到汇编代码，然后通过GDB（GNU Debugger）来知晓“炸弹”的引爆逻辑，并由此给出正确的解决文件solution.txt，正确地拆除全部phase的炸弹。如果成功独立完成了这个实验，相信你对GDB的使用和x86-64汇编语言的理解会上一个台阶。 实验文档与代码框架 实验文档请点击此链接查看。每">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://ziyuliu258.github.io/images/avatar.jpg">
<meta property="article:published_time" content="2026-02-18T08:54:45.000Z">
<meta property="article:modified_time" content="2026-02-25T18:06:11.644Z">
<meta property="article:author" content="Derrick Liu">
<meta property="article:tag" content="ICS实验">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://ziyuliu258.github.io/images/avatar.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "XJTU-ICS Lab 2: Bomb Lab",
  "url": "https://ziyuliu258.github.io/posts/8eada4ef/",
  "image": "https://ziyuliu258.github.io/images/avatar.jpg",
  "datePublished": "2026-02-18T08:54:45.000Z",
  "dateModified": "2026-02-25T18:06:11.644Z",
  "author": [
    {
      "@type": "Person",
      "name": "Derrick Liu",
      "url": "https://ziyuliu258.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="/images/avatar.jpg"><link rel="canonical" href="https://ziyuliu258.github.io/posts/8eada4ef/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":1,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: true,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: false,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'XJTU-ICS Lab 2: Bomb Lab',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="stylesheet" href="/css/custom.css"><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background-image: url(/images/bg2.jpg);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/images/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">13</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">7</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-handshake"></i><span> Friends</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(/images/bg2.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"></a><a class="nav-page-title" href="/"><span class="site-name">XJTU-ICS Lab 2: Bomb Lab</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-handshake"></i><span> Friends</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li></ul></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">XJTU-ICS Lab 2: Bomb Lab</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2026-02-18T08:54:45.000Z" title="发表于 2026-02-18 16:54:45">2026-02-18</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2026-02-25T18:06:11.644Z" title="更新于 2026-02-26 02:06:11">2026-02-26</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">11.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>44分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h2 id="前言">前言</h2>
<p><code>Bomb Lab</code>是课程的第二个实验，它给出了一个“炸弹”文件，要求学习者从可执行文件反汇编得到汇编代码，然后通过<code>GDB（GNU Debugger）</code>来知晓“炸弹”的引爆逻辑，并由此给出正确的解决文件<code>solution.txt</code>，正确地拆除全部phase的炸弹。如果成功独立完成了这个实验，相信你对<code>GDB</code>的使用和<code>x86-64</code>汇编语言的理解会上一个台阶。</p>
<h3 id="实验文档与代码框架">实验文档与代码框架</h3>
<p>实验文档请点击<a target="_blank" rel="noopener" href="https://xjtu-ics.github.io/labs/lab2">此链接</a>查看。每个人的<code>bomb</code>文件对应的正确答案是不一样的，所以似乎没有公开的代码框架，我仅在此处根据我自己的代码框架给出解法。代码以及参考解法我仍然上传到了我的这一<a target="_blank" rel="noopener" href="https://github.com/ziyuliu258/XJTU-ICS-Implement">仓库</a>中，读者可以自行参考。</p>
<h3 id="原则">原则</h3>
<p>如果你是一名正在选修ICS的XJTU的学生，请你务必首先尝试独立解决课程的所有实验，如果实在觉得想不出来了，再参考本文档的解法；非选课人士也可以参考此文档与代码框架，尝试自己完成这些实验。</p>
<h3 id="本文的侧重点">本文的侧重点</h3>
<p>我相信有很多同学在这个实验上遇到的困难不在于程序逻辑，而是<strong>工具的使用</strong>。如果你能完美地记住<code>GDB</code>的各种调试语句，那你的阻力会小很多。所以，我将在本文中总结一些<code>GDB</code>的实用技巧，并从具体的各个phase出发，展示如何使用这一调试工具分析、解决问题。</p>
<p>至于基础知识，我也会讲到一些最核心的部分，只不过可能不会非常细致，因为这些知识本应该从书本和课程中掌握，而不是一个实验解析应该负责的部分。</p>
<h3 id="参考实现">参考实现</h3>
<p>本人的实验代码会同步到这一<a target="_blank" rel="noopener" href="https://github.com/ziyuliu258/XJTU-ICS-Implement">仓库</a>，读者可以自行拉取到本地参考。但是，<strong>请一定要阅读仓库的<code>README</code>文件</strong>，坚持独立完成实验，不要抄袭。独立完成实验对于你的实际能力提升有很大帮助。</p>
<h2 id="实验内容与基本要求">实验内容与基本要求</h2>
<h3 id="基本任务">基本任务</h3>
<p>这个实验给出了一个6阶段的“炸弹”文件<code>bomb</code>，并且给出了基本的代码框架<code>bomb.c</code>。你需要根据可执行文件对应的汇编代码来获知代码的逻辑，获取能够成功拆弹的答案，并填到<code>solution.txt</code>中。</p>
<div class="markdown-alert markdown-alert-tip"><p class="markdown-alert-title"><svg class="octicon octicon-light-bulb mr-2" viewbox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="M8 1.5c-2.363 0-4 1.69-4 3.75 0 .984.424 1.625.984 2.304l.214.253c.223.264.47.556.673.848.284.411.537.896.621 1.49a.75.75 0 0 1-1.484.211c-.04-.282-.163-.547-.37-.847a8.456 8.456 0 0 0-.542-.68c-.084-.1-.173-.205-.268-.32C3.201 7.75 2.5 6.766 2.5 5.25 2.5 2.31 4.863 0 8 0s5.5 2.31 5.5 5.25c0 1.516-.701 2.5-1.328 3.259-.095.115-.184.22-.268.319-.207.245-.383.453-.541.681-.208.3-.33.565-.37.847a.751.751 0 0 1-1.485-.212c.084-.593.337-1.078.621-1.489.203-.292.45-.584.673-.848.075-.088.147-.173.213-.253.561-.679.985-1.32.985-2.304 0-2.06-1.637-3.75-4-3.75ZM5.75 12h4.5a.75.75 0 0 1 0 1.5h-4.5a.75.75 0 0 1 0-1.5ZM6 15.25a.75.75 0 0 1 .75-.75h2.5a.75.75 0 0 1 0 1.5h-2.5a.75.75 0 0 1-.75-.75Z"/></svg>Tip</p><p></p>
<p>实验并没有给出原始的汇编代码，<code>gdb</code>会在调试的时候自动调用内置的反汇编库获得该可执行程序的汇编代码，你也可以手动调用GNU的<code>objdump</code>工具来获取汇编代码文件。</p>
</div>
<p>这6个phase实际上就是6个函数，读取你输入的内容作为参数，每个phase的答案都是唯一的。只有你输入了正确的答案，才不会在当前阶段引爆炸弹。</p>
<h3 id="注意事项">注意事项</h3>
<ul>
<li>请你将你的答案分行写在<code>solution.txt</code>文件中，每一行对应一个phase的答案，多个变量中间用空格分隔；</li>
<li>如果答案包含字符串，不要用双引号包裹，直接敲入文件就可以。</li>
<li>输入完最后一个phase的答案后，请再留出<strong>一个空行</strong>，避免<code>EOF</code>标志被误认为被输进程序中的字符。</li>
</ul>
<h2 id="辅助内容">辅助内容</h2>
<p>在阅读这一节之前，读者不妨先参考课程文档以及其给出的各种辅助资料。这一部分只是并不完善、也远非严谨的个人总结。</p>
<h3 id="⚠️CS107-x86-64-Reference-Sheet">⚠️CS107 x86-64 Reference Sheet</h3>
<p>这是Stanford CS107课程Computer Organization &amp; Systems的一份参考资料，使用的教材也是CSAPP。这份Sheet比较全面地总结了常用的<code>x86-64</code>汇编指令、条件码的设置条件、以及各个通用寄存器约定俗成的用途等内容，非常有用。</p>
<p>可以通过CS107官网或者本课程官网获取：<a target="_blank" rel="noopener" href="https://web.stanford.edu/class/cs107/resources/x86-64-reference.pdf">CS107官网链接</a> <a target="_blank" rel="noopener" href="https://xjtu-ics.github.io/assets/files/x86-64-reference.pdf">XJTU-ICS托管资源</a> <a href="/posts/8eada4ef/x86-64-reference.pdf">本网站托管资源</a></p>
<h3 id="ASCII码对照表"><code>ASCII</code>码对照表</h3>
<p>无需多言此表的重要性，而这部分内容在后面解题的时候会用到。可以很轻易地从网上获取到这个对照表，在此给出一个<a target="_blank" rel="noopener" href="https://mcusoft.wordpress.com/wp-content/uploads/2015/07/ascii_code_table-1.pdf">版本</a>，本站托管文件<a href="/posts/8eada4ef/ascii_table.pdf">在此</a>。</p>
<h3 id="GDB常用命令"><code>GDB</code>常用命令</h3>
<h4 id="怎么开始？">怎么开始？</h4>
<p>在正式进入单步调试前，你还有很多指令要敲，下例给出开始调试时用到的几个必要的命令：</p>
<p><img src="/posts/8eada4ef/image-20260219211603203.png" alt></p>
<ul>
<li><code>b main</code>：也就是<code>break main</code>，在<code>main</code>函数的入口处打断点，从而能够让调试进行；也可以在某个特定地址处设断点，如<code>b 0xffffffff</code></li>
<li><code>info break</code>：查看所有断点信息；</li>
<li><code>delete [n]</code>：删除第n个断点，n值可以通过<code>info break</code>获取；</li>
<li><code>continue</code>：继续执行直到下一个断点；</li>
<li><code>debuginfod</code>：作用就是记录你的调试信息，一般来说不需要，也不用在意；</li>
<li><code>run &lt; solution.txt</code>：<code>run</code>是开始调试的指令，利用<code>&lt;</code>这一符号来输入<code>solution.txt</code>。</li>
</ul>
<p>接下来就可以进行具体的调试操作了。</p>
<h4 id="步进-步过">步进/步过</h4>
<p>在<code>GDB</code>中，常用的步进（Step In）/步过（Step Over）操作由指令来实现，分为<strong>源代码层级</strong>和<strong>机器指令层级</strong>（也就是汇编）。具体指令如下：</p>
<table>
<thead>
<tr>
<th><strong>维度</strong></th>
<th><strong>Step In (进入函数内部)</strong></th>
<th><strong>Step Over (跳过函数调用)</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>源代码层级</strong> (C 代码)</td>
<td><code>step</code> /<code>s</code></td>
<td><code>next</code> /<code>n</code></td>
</tr>
<tr>
<td><strong>机器指令层级</strong> (汇编)</td>
<td><code>stepi</code>/<code>si</code></td>
<td><code>nexti</code>/<code>ni</code></td>
</tr>
</tbody>
</table>
<p>由于我们这里主要根据汇编代码来分析程序，所以肯定是用<code>ni</code>和<code>si</code>最多。</p>
<h4 id="观察不同类型的值">观察不同类型的值</h4>
<p>我们主要通过 <strong><code>print</code>/<code>p</code></strong> （简写）和 <strong><code>examine</code>/<code>x</code></strong> （简写）来获取我们想要看到的数据。二者的区别在于<code>p</code>操作是仅仅查看存储单元所存之 <em><strong>值本身</strong></em> ，而<code>x</code>操作是把存储单元存储的值当作地址，读取这个 <em><strong>地址对应的内存中存放的值</strong></em> 。可以将后者当成一种 <strong>指针解引用</strong> 的操作。</p>
<p>既然是展示值，那么必然要涉及到以<strong>什么格式</strong>展示这个值。</p>
<h5 id="x操作"><code>x</code>操作</h5>
<p>examine指令的完整语法是<code>x / &lt;n&gt; &lt;f&gt; &lt;u&gt; addr</code>，这三个参数分别为</p>
<ul>
<li>
<p><code>&lt;n&gt;</code>：显示单位的数量，比如<code>x/4</code>可以表示查看连续的4个内存单元；</p>
</li>
<li>
<p><code>&lt;f&gt;</code>：显示的格式，和C语言的转义字符规定有相同之处</p>
<table>
<thead>
<tr>
<th><strong>参数</strong></th>
<th><strong>含义</strong></th>
<th><strong>常用场景</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong><code>x</code></strong></td>
<td><strong>Hexadecimal</strong> (十六进制)</td>
<td>查看该地址指向的内存单元存储的原始十六进制数值。</td>
</tr>
<tr>
<td><strong><code>s</code></strong></td>
<td><strong>String</strong> (字符串)</td>
<td>自动读取内存直到遇到 <code>\0</code> 为止。</td>
</tr>
<tr>
<td><strong><code>i</code></strong></td>
<td><strong>Instruction</strong> (汇编指令)</td>
<td>查看该内存地址存储的机器码对应的汇编指令。</td>
</tr>
<tr>
<td><strong><code>d</code></strong></td>
<td><strong>Decimal</strong> (十进制)</td>
<td>查看普通的整数变量。</td>
</tr>
<tr>
<td><strong><code>u</code></strong></td>
<td><strong>Unsigned decimal</strong> (无符号十进制)</td>
<td>查看无符号整数。</td>
</tr>
<tr>
<td><strong><code>t</code></strong></td>
<td><strong>Binary</strong> (二进制)</td>
<td>查看具体的位（Bit）状态（t 代表 two）。</td>
</tr>
<tr>
<td><strong><code>c</code></strong></td>
<td><strong>Char</strong> (字符)</td>
<td>查看单个字符。</td>
</tr>
</tbody>
</table>
</li>
<li>
<p><code>&lt;u&gt;</code>：单元大小，指定你要查看的一个单元占多少字节。</p>
<table>
<thead>
<tr>
<th><strong>参数</strong></th>
<th><strong>含义</strong></th>
<th><strong>字节数</strong></th>
<th><strong>对应 C 类型</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong><code>b</code></strong></td>
<td><strong>Byte</strong></td>
<td>1 字节</td>
<td><code>char</code></td>
</tr>
<tr>
<td><strong><code>h</code></strong></td>
<td><strong>Halfword</strong></td>
<td>2 字节</td>
<td><code>short</code></td>
</tr>
<tr>
<td><strong><code>w</code></strong></td>
<td><strong>Word</strong></td>
<td>4 字节</td>
<td><code>int</code> / <code>float</code></td>
</tr>
<tr>
<td><strong><code>g</code></strong></td>
<td><strong>Giant word</strong></td>
<td>8 字节</td>
<td><strong>x86-64 指针</strong> / <code>long</code></td>
</tr>
</tbody>
</table>
<p>在格式参数处选择<code>s</code>的时候，这里就不需指定了，因为字符串是默认读取到<code>\0</code>结束的。</p>
</li>
</ul>
<h5 id="p操作"><code>p</code>操作</h5>
<p><code>p</code> 指令的参数只有格式（Format），没有数量（Number）和单位（Unit）： <code>p /&lt;f&gt; &lt;expression&gt;</code>，它的功能比较简单，一次只支持看一个值，单位大小也不支持指定，而是由表达式的具体类型决定，比如一个寄存器<code>%rax</code>就是8字节，因此就会展示8字节的数据。</p>
<table>
<thead>
<tr>
<th><strong>格式参数</strong></th>
<th><strong>全称</strong></th>
<th><strong>显示内容</strong></th>
<th><strong>炸弹实验场景</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>/x</strong></td>
<td><strong>Hexadecimal</strong></td>
<td><strong>十六进制</strong>。显示最原始的数值。</td>
<td>看内存地址、看寄存器值。</td>
</tr>
<tr>
<td><strong>/d</strong></td>
<td><strong>Decimal</strong></td>
<td><strong>有符号十进制</strong>。</td>
<td>看普通的整数比较（如 <code>cmp $0x5, %eax</code>）。</td>
</tr>
<tr>
<td><strong>/u</strong></td>
<td><strong>Unsigned</strong></td>
<td><strong>无符号十进制</strong>。</td>
<td>当处理很大的正数，或者不希望看到负号时使用。</td>
</tr>
<tr>
<td><strong>/t</strong></td>
<td><strong>Two (Binary)</strong></td>
<td><strong>二进制</strong>。显示 0 和 1。</td>
<td>查看<strong>标志位</strong>或进行<strong>位运算</strong>（AND/OR/XOR）调试。</td>
</tr>
<tr>
<td><strong>/c</strong></td>
<td><strong>Char</strong></td>
<td><strong>字符</strong>。按照 ASCII 码翻译。</td>
<td>查看寄存器里存的是不是某个特定字符（如 ‘A’）。</td>
</tr>
<tr>
<td><strong>/a</strong></td>
<td><strong>Address</strong></td>
<td><strong>地址模式</strong>。</td>
<td>它会尝试告诉你这个地址属于哪个函数（如 <code>0x401234 &lt;main+20&gt;</code>）。</td>
</tr>
<tr>
<td><strong>/f</strong></td>
<td><strong>Float</strong></td>
<td><strong>浮点数</strong>。</td>
<td>查看浮点运算寄存器的值。</td>
</tr>
</tbody>
</table>
<h5 id="display命令"><code>display</code>命令</h5>
<p>这个命令可以在每次程序执行完一步后都打印出你指定的内存单元的值，它兼容<code>p</code>/<code>x</code>指令的参数形式，因此按照给出的参数不同，有可能展示存放的值（地址）本身，也可能展示地址对应的单元的值。</p>
<p><img src="/posts/8eada4ef/image-20260220004611315.png" alt></p>
<p>下图是一个示例，可以验证以上<code>Gemini</code>的说法：</p>
<p><img src="/posts/8eada4ef/image-20260220005144922.png" alt></p>
<h5 id="寄存器信息查询">寄存器信息查询</h5>
<p>使用<code>info reg</code>命令，查看所有寄存器的值。</p>
<p><img src="/posts/8eada4ef/image-20260220010401049.png" alt></p>
<h4 id="倒退操作">倒退操作</h4>
<p>在<code>GDB</code>中，如果不特意设置，只能单向调试，而不能在遇到问题时倒回来。如果要倒退，那就要开启<code>record</code>模式。</p>
<p><code>record</code>也分为不同的方式。一种是默认的<code>full</code>全记录模式，需要在执行<code>run</code>命令之前先输入<code>target record-full</code>。但是由于<code>record</code>要保存寄存器快照、内存变更日志以及指令序列等信息，会导致调试的空间效率和时间效率大大降低，所以不建议开启<code>full</code>模式。</p>
<p>更好的方法是，在调试的过程中，遇到你觉得可能需要记录的地方时，输入<code>record</code>命令，开始记录；在通过某个需要用到倒退功能的片段后，及时使用<code>record stop</code>命令清空内存日志。</p>
<p>下面将常用命令在表格中总结：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>缩写</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>target record-full</code></td>
<td></td>
<td>略</td>
</tr>
<tr>
<td><code>record</code></td>
<td></td>
<td>略</td>
</tr>
<tr>
<td><code>record stop</code></td>
<td></td>
<td>略</td>
</tr>
<tr>
<td><code>reverse-stepi &lt;N&gt;</code></td>
<td><code>rsi &lt;N&gt;</code></td>
<td>反向步进（N步）</td>
</tr>
<tr>
<td><code>reverse-nexti &lt;N&gt;</code></td>
<td><code>rni &lt;N&gt;</code></td>
<td>反向步过（N步）</td>
</tr>
<tr>
<td><code>reverse-continue</code></td>
<td><code>rc</code></td>
<td>回退到上一个断点</td>
</tr>
<tr>
<td><code>set record instruction-history-size &lt;N&gt;/unlimited</code></td>
<td></td>
<td>设置缓冲区容纳的最大指令条数为N条/无限</td>
</tr>
</tbody>
</table>
<p>下例给出一个实际应用：</p>
<p><img src="/posts/8eada4ef/image-20260219235244243.png" alt></p>
<p><img src="/posts/8eada4ef/image-20260219235319580.png" alt></p>
<blockquote>
<p>可以看到，在执行了<code>rsi 2</code>之后，立刻回到了两条汇编指令之前。</p>
</blockquote>
<h4 id="⚠️TUI模式">⚠️TUI模式</h4>
<p><strong>TUI (Text User Interface)</strong> 是 GDB 的“分屏增强模式”。它支持你在单步调试的时候<strong>边看代码边调试</strong>，还能监视各种寄存器的值。这是非常关键的一个功能，能够让调试方便许多，让你从频繁的<code>x/i $rip</code>操作中解脱出来。</p>
<p><img src="/posts/8eada4ef/image-20260220000539957.png" alt></p>
<p>你可以在开始调试时随时通过<code>Ctrl + X + A</code>来进入/退出TUI模式，然后输入<code>layout asm</code>调取汇编代码界面，<code>layout regs</code>调取寄存器窗口（寄存器数值变动的时候会高亮）。</p>
<p>但是，注意这个时候你可能没法使用键盘的<code>Up</code> <code>Down</code>来调取上一个输入的命令，也没法用鼠标选中文字了，因为此时默认你的“焦点（Focus）”是在代码窗口上的，所以上/下键就用来滚动浏览汇编代码了，鼠标也没法直接选中终端文字了。这个时候你可以使用<code>Ctrl + P/N</code>来代替<code>Up</code>/<code>Down</code>方向键，可以按住<code>Shift</code>同时使用鼠标选中文字复制/粘贴。又或者你可以直接输入<code>focus cmd</code>将焦点转回到命令行，在使用完之后再输入<code>focus asm</code>切换回代码窗口。</p>
<p>下表总结可能常用到的TUI模式下的操作：</p>
<table>
<thead>
<tr>
<th><strong>类别</strong></th>
<th><strong>命令 / 快捷键</strong></th>
<th><strong>作用描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>模式切换</strong></td>
<td><code>Ctrl + X</code> + <code>A</code></td>
<td>开关 TUI</td>
</tr>
<tr>
<td></td>
<td><code>layout asm</code></td>
<td>显示汇编</td>
</tr>
<tr>
<td></td>
<td><code>layout regs</code></td>
<td>在上方开启寄存器窗口，数值变化会变红。</td>
</tr>
<tr>
<td></td>
<td><code>layout src</code></td>
<td>显示源码</td>
</tr>
<tr>
<td></td>
<td><code>layout split</code></td>
<td>分屏，同时显示源码和汇编。</td>
</tr>
<tr>
<td><strong>窗口焦点</strong></td>
<td><code>focus cmd</code></td>
<td>控制权给命令行：恢复方向键调取历史命令的功能。</td>
</tr>
<tr>
<td></td>
<td><code>focus asm</code></td>
<td>控制权给汇编：方向键变为滚动查看代码。</td>
</tr>
<tr>
<td></td>
<td><code>Ctrl + X</code> + <code>O</code></td>
<td>循环切换焦点：在已打开的窗口间轮转焦点。</td>
</tr>
<tr>
<td><strong>命令导航</strong></td>
<td><code>Ctrl + P</code></td>
<td>等同于“上方向键”</td>
</tr>
<tr>
<td></td>
<td><code>Ctrl + N</code></td>
<td>等同于“下方向键”。</td>
</tr>
<tr>
<td><strong>显示修复</strong></td>
<td><code>Ctrl + L</code></td>
<td>刷新屏幕：当程序输出导致花屏时，刷新修复。</td>
</tr>
<tr>
<td><strong>高效操作</strong></td>
<td><code>Ctrl + X</code> + <code>S</code></td>
<td>单键模式：按 <code>n</code> 为<code>next</code>，按 <code>s</code> 为<code>step</code>，按<code>c</code>为<code>continue</code>。</td>
</tr>
<tr>
<td></td>
<td><code>winheight asm +5</code></td>
<td>调整高度：给汇编窗口增加 5 行高度。</td>
</tr>
<tr>
<td><strong>终端模拟器处理鼠标事件</strong></td>
<td><code>Shift</code> + 鼠标操作</td>
<td>临时使用鼠标完成某些操作。</td>
</tr>
</tbody>
</table>
<h2 id="题解">题解</h2>
<h3 id="源代码">源代码</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***************************************************************************</span></span><br><span class="line"><span class="comment"> * Dr. Evil&#x27;s Insidious Bomb, Version 1.1</span></span><br><span class="line"><span class="comment"> * Copyright 2011, Dr. Evil Incorporated. All rights reserved.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * LICENSE:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Dr. Evil Incorporated (the PERPETRATOR) hereby grants you (the</span></span><br><span class="line"><span class="comment"> * VICTIM) explicit permission to use this bomb (the BOMB).  This is a</span></span><br><span class="line"><span class="comment"> * time limited license, which expires on the death of the VICTIM.</span></span><br><span class="line"><span class="comment"> * The PERPETRATOR takes no responsibility for damage, frustration,</span></span><br><span class="line"><span class="comment"> * insanity, bug-eyes, carpal-tunnel syndrome, loss of sleep, or other</span></span><br><span class="line"><span class="comment"> * harm to the VICTIM.  Unless the PERPETRATOR wants to take credit,</span></span><br><span class="line"><span class="comment"> * that is.  The VICTIM may not distribute this bomb source code to</span></span><br><span class="line"><span class="comment"> * any enemies of the PERPETRATOR.  No VICTIM may debug,</span></span><br><span class="line"><span class="comment"> * reverse-engineer, run &quot;strings&quot; on, decompile, decrypt, or use any</span></span><br><span class="line"><span class="comment"> * other technique to gain knowledge of and defuse the BOMB.  BOMB</span></span><br><span class="line"><span class="comment"> * proof clothing may not be worn when handling this program.  The</span></span><br><span class="line"><span class="comment"> * PERPETRATOR will not apologize for the PERPETRATOR&#x27;s poor sense of</span></span><br><span class="line"><span class="comment"> * humor.  This license is null and void where the BOMB is prohibited</span></span><br><span class="line"><span class="comment"> * by law.</span></span><br><span class="line"><span class="comment"> ***************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;support.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;phases.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * Note to self: Remember to erase this file so my victims will have no</span></span><br><span class="line"><span class="comment"> * idea what is going on, and so they will all blow up in a</span></span><br><span class="line"><span class="comment"> * spectaculary fiendish explosion. -- Dr. Evil </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">FILE *infile;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *input;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Note to self: remember to port this bomb to Windows and put a </span></span><br><span class="line"><span class="comment">     * fantastic GUI on it. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* When run with no arguments, the bomb reads its input lines </span></span><br><span class="line"><span class="comment">     * from standard input. */</span></span><br><span class="line">    <span class="keyword">if</span> (argc == <span class="number">1</span>) &#123;  </span><br><span class="line">	infile = <span class="built_in">stdin</span>;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">/* When run with one argument &lt;file&gt;, the bomb reads from &lt;file&gt; </span></span><br><span class="line"><span class="comment">     * until EOF, and then switches to standard input. Thus, as you </span></span><br><span class="line"><span class="comment">     * defuse each phase, you can add its defusing string to &lt;file&gt; and</span></span><br><span class="line"><span class="comment">     * avoid having to retype it. */</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (argc == <span class="number">2</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> (!(infile = fopen(argv[<span class="number">1</span>], <span class="string">&quot;r&quot;</span>))) &#123;</span><br><span class="line">	    <span class="built_in">printf</span>(<span class="string">&quot;%s: Error: Couldn&#x27;t open %s\n&quot;</span>, argv[<span class="number">0</span>], argv[<span class="number">1</span>]);</span><br><span class="line">	    <span class="built_in">exit</span>(<span class="number">8</span>);</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* You can&#x27;t call the bomb with more than 1 command line argument. */</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Usage: %s [&lt;input_file&gt;]\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">8</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Do all sorts of secret stuff that makes the bomb harder to defuse. */</span></span><br><span class="line">    initialize_bomb();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Welcome to my fiendish little bomb. You have 6 phases with\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;which to blow yourself up. Have a nice day!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Hmm...  Six phases must be more secure than one phase! */</span></span><br><span class="line">    input = read_line();             <span class="comment">/* Get input                   */</span></span><br><span class="line">    phase_1(input);                  <span class="comment">/* Run the phase               */</span></span><br><span class="line">    phase_defused();                 <span class="comment">/* Drat!  They figured it out!</span></span><br><span class="line"><span class="comment">				      * Let me know how they did it. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The second phase is harder.  No one will ever figure out</span></span><br><span class="line"><span class="comment">     * how to defuse this... */</span></span><br><span class="line">    input = read_line();</span><br><span class="line">    phase_2(input);</span><br><span class="line">    phase_defused();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* I guess this is too easy so far.  Some more complex code will</span></span><br><span class="line"><span class="comment">     * confuse people. */</span></span><br><span class="line">    input = read_line();</span><br><span class="line">    phase_3(input);</span><br><span class="line">    phase_defused();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Oh yeah?  Well, how good is your math?  Try on this saucy problem! */</span></span><br><span class="line">    input = read_line();</span><br><span class="line">    phase_4(input);</span><br><span class="line">    phase_defused();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Round and &#x27;round in memory we go, where we stop, the bomb blows! */</span></span><br><span class="line">    input = read_line();</span><br><span class="line">    phase_5(input);</span><br><span class="line">    phase_defused();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* This phase will never be used, since no one will get past the</span></span><br><span class="line"><span class="comment">     * earlier ones.  But just in case, make this one extra hard. */</span></span><br><span class="line">    input = read_line();</span><br><span class="line">    phase_6(input);</span><br><span class="line">    phase_defused();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Wow, they got it!  But isn&#x27;t something... missing?  Perhaps</span></span><br><span class="line"><span class="comment">     * something they overlooked?  Mua ha ha ha ha! */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>程序的注释很有意思，感兴趣的读者可以读一读，开头的许可证的中文翻译如下：</p>
<blockquote>
<p><strong>邪恶博士的阴险炸弹，版本 1.1</strong></p>
<p><strong>版权所有 2011，邪恶博士有限公司。保留所有权利。</strong></p>
<p><strong>许可证：</strong></p>
<p>邪恶博士有限公司（以下简称 <strong>作恶者</strong>）在此授予您（以下简称 <strong>受害者</strong>）使用此炸弹（以下简称 <strong>本炸弹</strong>）的明确许可。这是一种有限期的许可证，将在 <strong>受害者</strong> 死亡时过期。</p>
<p><strong>作恶者</strong> 对因本程序造成的损害、挫败、精神失常、金鱼眼（bug-eyes）、腕管综合征、失眠或其他对 <strong>受害者</strong> 的伤害概不负责。除非 <strong>作恶者</strong> 想要揽功，那是另一回事。</p>
<p><strong>受害者</strong> 不得将本炸弹的源代码分发给 <strong>作恶者</strong> 的任何敌人。任何 <strong>受害者</strong> 均不得对本程序进行调试、逆向工程、运行 “strings” 命令、反编译、解密，或使用任何其他技术来获取本炸弹的相关知识或拆除本炸弹。</p>
<p>在处理本程序时，不得穿着防爆服。</p>
<p><strong>作恶者</strong> 不会为他那拙劣的幽默感道歉。</p>
<p>在法律禁止本炸弹的地区，本许可证无效。</p>
</blockquote>
<h3 id="汇编代码">汇编代码</h3>
<p>这里我们使用<code>objdump -d bomb &gt; bomb.s</code>来生成汇编语言文件。整个汇编代码很长，我们会在下面结合它来分析各个phase的程序逻辑。</p>
<h3 id="phase-1：字符串比较"><code>phase_1</code>：字符串比较</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">    14e0:	e8 63 07 00 00       	call   1c48 &lt;read_line&gt;</span><br><span class="line">    14e5:	48 89 c7             	mov    %rax,%rdi</span><br><span class="line">    14e8:	e8 be 00 00 00       	call   15ab &lt;phase_1&gt;</span><br><span class="line">    14ed:	e8 aa 08 00 00       	call   1d9c &lt;phase_defused&gt;</span><br><span class="line">	# ......</span><br><span class="line">00000000000015ab &lt;phase_1&gt;:</span><br><span class="line">    15ab:	f3 0f 1e fa          	endbr64</span><br><span class="line">    15af:	48 83 ec 08          	sub    $0x8,%rsp</span><br><span class="line">    15b3:	48 8d 35 f2 1a 00 00 	lea    0x1af2(%rip),%rsi        # 30ac &lt;_IO_stdin_used+0xac&gt;</span><br><span class="line">    15ba:	e8 d8 04 00 00       	call   1a97 &lt;strings_not_equal&gt;</span><br><span class="line">    15bf:	85 c0                	test   %eax,%eax # if string not equal returns 0, ZF=1; else ZF=0;</span><br><span class="line">    15c1:	75 05                	jne    15c8 &lt;phase_1+0x1d&gt; # d=13 JUMP IF eax NOT EQUAL 0; ZF=0 then jump --&gt; string equal then jump</span><br><span class="line">    15c3:	48 83 c4 08          	add    $0x8,%rsp # return to original stack state</span><br><span class="line">    15c7:	c3                   	ret</span><br><span class="line">    15c8:	e8 de 05 00 00       	call   1bab &lt;explode_bomb&gt;</span><br><span class="line">    15cd:	eb f4                	jmp    15c3 &lt;phase_1+0x18&gt;</span><br></pre></td></tr></table></figure>
<h4 id="快速解题">快速解题</h4>
<p>如果要一步一步查看过程中的所有代码，一定会很麻烦。这一题不妨可以跳过<code>strings_not_equal</code>的代码细节，将它当成一个“黑盒子”，这样就简单得多。从字面意义上推测，这个函数有可能是一个判断器。我们不妨假设：<u><strong>如果送进去的特定数量的字符串内容相同，就返回0（False）；不相同则返回1（True）</strong></u>。</p>
<p>分析<code>strings_not_equal</code>的<strong>入参</strong>，我们首先可以看到，首参<code>%rdi</code>在<code>main</code>函数调用<code>phase_1</code>之前被设置好了，内容就是第一行输入（<code>14e5</code>）；而调用前的<code>lea</code>指令把一个地址加载到了第二参数寄存器<code>%rsi</code>中，所以我们可以推测出，这个函数总共接收两个参数。那么这个函数的作用有可能就是判断输入的字符串是否与程序中内置的字符串相等。而<code>%ax</code>寄存器存放的是函数的<strong>返回值</strong>，假设这个函数返回布尔值或者<code>1</code>/<code>0</code>来表示，那么只要两个字符串不相等——返回值为1——<code>test</code>指令检测出返回值不为0——就会跳转到<code>15c8</code>引爆炸弹。所以只需要在调试的时候找到<code>%rsi</code>存储的地址处的字符串内容，并填到输入文本的第一行，就解决了。</p>
<h4 id="实际操作">实际操作</h4>
<p><img src="/posts/8eada4ef/image-20260220013743858.png" alt="解题过程"></p>
<p>我们通过调试，获得了传入函数<code>strings_not_equal</code>的第二参数，是字符串<code>Crikey! I have lost my mojo!</code>。把它输入到<code>solution.txt</code>中，就能成功拆除<code>phase_1</code>的炸弹。</p>
<h4 id="知识补充">知识补充</h4>
<ul>
<li>
<p>栈管理</p>
<p>首先，观察一下汇编代码的结构，我们可以发现，<code>sub    $0x8,%rsp</code>和<code>add    $0x8,%rsp</code>这两句是一个函数调用过程中标准的<strong>栈管理指令</strong>。由于在<code>x86-64</code>架构中，Stack是向低地址增长的，所以<code>sub</code>的作用是申请8字节的临时空间，用于对齐栈顶或者存放局部变量；而<code>add</code>就是在函数执行结束前<strong>收回栈帧（“销毁”空间）</strong>， 恢复栈指针原位，维持<strong>栈平衡</strong>。最后<code>ret</code>指令弹出当前<code>%rsp</code>指向位置的值，将值加载到<code>%rip</code>中（<code>%rsp</code>存储的这个值通常是下一条指令的地址，<code>call</code>指令提前将它压入此处），回到调用前的状态。</p>
</li>
<li>
<p><code>lea</code>指令</p>
<p><code>lea    0x1af2(%rip),%rsi</code>这句指令有一个逻辑上的细节。你可能会发现，如果在这条指令执行之前，直接按照这个偏移量来获取字符串，可能并没有找到正确答案。实际上，这是因为<code>(0x1af2 + %rip) -&gt; %rsi</code>这个逻辑是发生在<code>PC &lt;- (PC) + 1</code>这个步骤之后的。这个问题涉及到了一个很关键的知识点，它在<strong>计算机组成原理</strong>课程中也会被进一步介绍。</p>
<p>简单来说，现在CPU通常采用五级流水线架构，也就是一条指令分为五个阶段：“取指——译码——执行——访存——写回”。程序计数器自动增加一个指令长度的环节发生在<strong>取指</strong>阶段，也就是说<code>%rip</code>自动累加这个操作在这阶段已经完成；而真正实现计算 <code>0x1af2 + %rip</code> 这个加法是在<strong>执行</strong>阶段。</p>
<p>所以，<code>%rip</code>的值需要先增加一个指令的长度，然后再和这个偏移量相加，放到<code>%rsi</code>上。而<code>x86-64</code>采用的是<strong>CISC架构</strong>，使用的是<strong>变长指令集</strong>，因此每个指令的长度是不一样的，所以最好要在这个指令执行完之后再使用<code>x</code>指令获取字符串，或者直接查看<code>%rsi</code>的值，要不然就要在这个指令执行前使用<code>x/s ($rip + 0x1af2 + 0x7)</code>来获取字符串，因为<code>lea</code>的长度是7字节。</p>
</li>
<li>
<p><code>test</code>指令</p>
<p><code>test</code>指令会将两个操作数按位相与，然后根据结果设置标志位。而<code>eax</code>/<code>rax</code>又是约定俗成的存储<strong>返回值</strong>的寄存器。这就意味着，如果假设<code>strings_not_equal</code>返回一个布尔值/int值<code>1/0</code>到<code>%eax</code>中，代表“两字符串不相等”这一判断的真假；1是两个字符串不相同，0是两个字符串相同。那么若 <code>%eax</code> 不为0，<code>ZF</code>将不会被置1，于是<code>%rip</code>就会跳转到<code>15c8</code>，“炸弹”爆炸，拆弹失败。这就印证了我们的猜想：一定要让传入的字符串和程序中存储的字符串相同。</p>
</li>
</ul>
<h3 id="phase-2：数列找规律"><code>phase_2</code>：数列找规律</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">00000000000015cf &lt;phase_2&gt;:</span><br><span class="line">    15cf:	f3 0f 1e fa          	endbr64</span><br><span class="line">    15d3:	55                   	push   %rbp</span><br><span class="line">    15d4:	53                   	push   %rbx</span><br><span class="line">    15d5:	48 83 ec 28          	sub    $0x28,%rsp</span><br><span class="line">    15d9:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax</span><br><span class="line">    15e0:	00 00 </span><br><span class="line">    15e2:	48 89 44 24 18       	mov    %rax,0x18(%rsp)</span><br><span class="line">    15e7:	31 c0                	xor    %eax,%eax</span><br><span class="line">    15e9:	48 89 e6             	mov    %rsp,%rsi</span><br><span class="line">    15ec:	e8 12 06 00 00       	call   1c03 &lt;read_six_numbers&gt;</span><br><span class="line">    15f1:	83 3c 24 00          	cmpl   $0x0,(%rsp)</span><br><span class="line">    15f5:	78 0a                	js     1601 &lt;phase_2+0x32&gt;</span><br><span class="line">    15f7:	48 89 e5             	mov    %rsp,%rbp</span><br><span class="line">    15fa:	bb 01 00 00 00       	mov    $0x1,%ebx</span><br><span class="line">    15ff:	eb 13                	jmp    1614 &lt;phase_2+0x45&gt;</span><br><span class="line">    1601:	e8 a5 05 00 00       	call   1bab &lt;explode_bomb&gt;</span><br><span class="line">    1606:	eb ef                	jmp    15f7 &lt;phase_2+0x28&gt;</span><br><span class="line">    1608:	83 c3 01             	add    $0x1,%ebx </span><br><span class="line">    160b:	48 83 c5 04          	add    $0x4,%rbp</span><br><span class="line">    160f:	83 fb 06             	cmp    $0x6,%ebx </span><br><span class="line">    1612:	74 11                	je     1625 &lt;phase_2+0x56&gt;</span><br><span class="line">    1614:	89 d8                	mov    %ebx,%eax </span><br><span class="line">    1616:	03 45 00             	add    0x0(%rbp),%eax</span><br><span class="line">    1619:	39 45 04             	cmp    %eax,0x4(%rbp)</span><br><span class="line">    161c:	74 ea                	je     1608 &lt;phase_2+0x39&gt;</span><br><span class="line">    161e:	e8 88 05 00 00       	call   1bab &lt;explode_bomb&gt;</span><br><span class="line">    1623:	eb e3                	jmp    1608 &lt;phase_2+0x39&gt;</span><br><span class="line">    1625:	48 8b 44 24 18       	mov    0x18(%rsp),%rax</span><br><span class="line">    162a:	64 48 2b 04 25 28 00 	sub    %fs:0x28,%rax</span><br><span class="line">    1631:	00 00 </span><br><span class="line">    1633:	75 07                	jne    163c &lt;phase_2+0x6d&gt;</span><br><span class="line">    1635:	48 83 c4 28          	add    $0x28,%rsp</span><br><span class="line">    1639:	5b                   	pop    %rbx</span><br><span class="line">    163a:	5d                   	pop    %rbp</span><br><span class="line">    163b:	c3                   	ret</span><br><span class="line">    163c:	e8 0f fc ff ff       	call   1250 &lt;__stack_chk_fail@plt&gt;</span><br><span class="line">    </span><br><span class="line">    # ...</span><br><span class="line">0000000000001c03 &lt;read_six_numbers&gt;:</span><br><span class="line">    1c03:	f3 0f 1e fa          	endbr64</span><br><span class="line">    1c07:	48 83 ec 08          	sub    $0x8,%rsp</span><br><span class="line">    1c0b:	48 89 f2             	mov    %rsi,%rdx</span><br><span class="line">    1c0e:	48 8d 4e 04          	lea    0x4(%rsi),%rcx</span><br><span class="line">    1c12:	48 8d 46 14          	lea    0x14(%rsi),%rax</span><br><span class="line">    1c16:	50                   	push   %rax</span><br><span class="line">    1c17:	48 8d 46 10          	lea    0x10(%rsi),%rax</span><br><span class="line">    1c1b:	50                   	push   %rax</span><br><span class="line">    1c1c:	4c 8d 4e 0c          	lea    0xc(%rsi),%r9</span><br><span class="line">    1c20:	4c 8d 46 08          	lea    0x8(%rsi),%r8</span><br><span class="line">    1c24:	48 8d 35 01 17 00 00 	lea    0x1701(%rip),%rsi        # 332c &lt;array.0+0x22c&gt;</span><br><span class="line">    1c2b:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line">    1c30:	e8 cb f6 ff ff       	call   1300 &lt;__isoc99_sscanf@plt&gt;</span><br><span class="line">    1c35:	48 83 c4 10          	add    $0x10,%rsp</span><br><span class="line">    1c39:	83 f8 05             	cmp    $0x5,%eax</span><br><span class="line">    1c3c:	7e 05                	jle    1c43 &lt;read_six_numbers+0x40&gt;</span><br><span class="line">    1c3e:	48 83 c4 08          	add    $0x8,%rsp</span><br><span class="line">    1c42:	c3                   	ret</span><br><span class="line">    1c43:	e8 63 ff ff ff       	call   1bab &lt;explode_bomb&gt;</span><br></pre></td></tr></table></figure>
<h4 id="快速解题-2">快速解题</h4>
<p>这道题一上来，我们就可以看到<code>read_six_numbers</code>，所以我们姑且认为需要输入的就是6个数字。我们仍然可以不纠结<code>read_six_numbers</code>的细节，直接看主框架。</p>
<p>我们注意到，在调用完这个函数后，后面跟了一个比较语句<code>cmpl   $0x0,(%rsp)</code>和一个判断语句<code>js     1601 &lt;phase_2+0x32&gt;</code>，也就是说：如果<code>(%rsp)</code>小于0，那就直接爆炸。那么<code>(%rsp)</code>里面是什么值呢？我们通过调试可以得出（见下图），<code>read_six_numbers</code>得到的第一个数字就存放在<code>%rsp</code>处，往后按照顺序每4个字节存放一个数字，总共六个数字。4字节的大小正好对应<code>int</code>类型占用的字节数。</p>
<p><img src="/posts/8eada4ef/image-20260221020006580.png" alt></p>
<p>所以得到<strong>第一个结论：第一个数字需要是非负（整）数。</strong></p>
<div class="markdown-alert markdown-alert-note"><p class="markdown-alert-title"><svg class="octicon octicon-info mr-2" viewbox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z"/></svg>Note</p><p></p>
<ul>
<li><code>read_six_numbers</code>的细节会放在下面讲解。</li>
<li>关于<code>cmpl</code>和<code>js</code>指令，请参考前文提到的Reference Sheet。</li>
<li>因为本章学习内容根本不涉及浮点数，我们的lab也不会涉及到浮点类型的数据，浮点数的内容可以找到CSAPP原书对应的部分阅读学习。</li>
</ul>
</div>
<p>接着看，后面的代码把六个数字的起始地址放到了<code>%rbp</code>中，然后<code>%ebx</code>寄存器被初始化为1 。以下跳转到<code>1614</code>处，程序先给第一个数字加上<code>%ebx</code>，然后让它和后一个数字比较。如果不相等，就会爆炸；如果相等，就会让<code>%ebx</code>+1 ，<code>%rbp</code>向后4字节，也就是继续检查第二个数字。下面对第二个数字的操作也是相同的：先加上<code>%ebx</code>，然后和后一个数字比较，相等则<code>%ebx</code>继续自增1。直到<code>%ebx</code>为6的时候，证明第五个数字加上当时的<code>%ebx</code>（值为5）与第六个数字也相等，由此跳出循环，拆弹成功。</p>
<p>所以我们可以得到<strong>第二个结论：输入的数列<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">{</mo><msub><mi>a</mi><mi>n</mi></msub><msubsup><mo stretchy="false">}</mo><mrow><mi>n</mi><mo>=</mo><mn>1</mn></mrow><mn>6</mn></msubsup></mrow><annotation encoding="application/x-tex">\{a_n\}_{n=1}^6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose"><span class="mclose">}</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-2.4519em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2481em;"><span></span></span></span></span></span></span></span></span></span>必须满足以下规律：</strong></p>
<!-- $$
\begin{cases}
a_1 \ge 0 \\
a_{i+1} - a_i = i,\quad i=1,2,\dots,5
\end{cases}
$$ -->
<ul>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">a_1 &gt; 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6891em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>；</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>−</mo><msub><mi>a</mi><mi>i</mi></msub><mo>=</mo><mi>i</mi></mrow><annotation encoding="application/x-tex">a_{i+1} - a_{i}=i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7917em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span></li>
</ul>
<p>所以一个可能的答案为：<code>1 2 4 7 11 16</code>。当然，开头数字可以是任意非负数，所以答案不唯一。</p>
<h4 id="知识补充-2">知识补充</h4>
<h5 id="read-six-numbers解析"><code>read_six_numbers</code>解析</h5>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">0000000000001c03 &lt;read_six_numbers&gt;:</span><br><span class="line">    1c03:	f3 0f 1e fa          	endbr64</span><br><span class="line">    1c07:	48 83 ec 08          	sub    $0x8,%rsp</span><br><span class="line">    1c0b:	48 89 f2             	mov    %rsi,%rdx</span><br><span class="line">    1c0e:	48 8d 4e 04          	lea    0x4(%rsi),%rcx</span><br><span class="line">    1c12:	48 8d 46 14          	lea    0x14(%rsi),%rax</span><br><span class="line">    1c16:	50                   	push   %rax</span><br><span class="line">    1c17:	48 8d 46 10          	lea    0x10(%rsi),%rax</span><br><span class="line">    1c1b:	50                   	push   %rax</span><br><span class="line">    1c1c:	4c 8d 4e 0c          	lea    0xc(%rsi),%r9</span><br><span class="line">    1c20:	4c 8d 46 08          	lea    0x8(%rsi),%r8</span><br><span class="line">    1c24:	48 8d 35 01 17 00 00 	lea    0x1701(%rip),%rsi        # 332c &lt;array.0+0x22c&gt;</span><br><span class="line">    1c2b:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line">    1c30:	e8 cb f6 ff ff       	call   1300 &lt;__isoc99_sscanf@plt&gt;</span><br><span class="line">    1c35:	48 83 c4 10          	add    $0x10,%rsp</span><br><span class="line">    1c39:	83 f8 05             	cmp    $0x5,%eax</span><br><span class="line">    1c3c:	7e 05                	jle    1c43 &lt;read_six_numbers+0x40&gt;</span><br><span class="line">    1c3e:	48 83 c4 08          	add    $0x8,%rsp</span><br><span class="line">    1c42:	c3                   	ret</span><br><span class="line">    1c43:	e8 63 ff ff ff       	call   1bab &lt;explode_bomb&gt;</span><br></pre></td></tr></table></figure>
<p>这里的重点在于，为什么这个函数就能将读取的六个数字放到<code>%rsp</code>处。其中的重点就是<code>sscanf</code>函数的使用。</p>
<p><code>sscanf</code>的详细介绍可以通过<code>man</code>命令查询，或者更好的方法是向现在发达的大语言模型发问。以下是执行<code>man sscanf</code>命令查询后的部分介绍文字，可以看到，它的作用大概就是<strong>按照<code>format</code>的规则处理输入的<code>str</code>，处理的结果存放在后面的参数里</strong>；<strong>返回值是成功处理的元素的数量</strong>。</p>
<p><img src="/posts/8eada4ef/image-20260221023336852.png" alt></p>
<p><img src="/posts/8eada4ef/image-20260221031208813.png" alt></p>
<p>而从<code>main</code>函数中，我们可以知道，<code>%rdi</code>就是我们输入的承载六个数字的字符串起始地址；二参数是格式化字符串，这个可以不深究；后面的参数，我们推测是存放六个数字的地址。所以，根据汇编代码总结一下，传参情况如下表所示：</p>
<table>
<thead>
<tr>
<th>参数序号</th>
<th>寄存器</th>
<th><code>sscanf</code> 中对应的含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>第1个</td>
<td><code>%rdi</code></td>
<td>输入字符串（六个数字）</td>
</tr>
<tr>
<td>第2个</td>
<td><code>%rsi</code></td>
<td>格式字符串 <code>0x1701(%rip),%rsi</code></td>
</tr>
<tr>
<td>第3个</td>
<td><code>%rdx</code></td>
<td><code>&amp;num[0]</code> → <code>(%rsp)</code></td>
</tr>
<tr>
<td>第4个</td>
<td><code>%rcx</code></td>
<td><code>&amp;num[1]</code> → <code>4(%rsp)</code></td>
</tr>
<tr>
<td>第5个</td>
<td><code>%r8</code></td>
<td><code>&amp;num[2]</code> → <code>8(%rsp)</code></td>
</tr>
<tr>
<td>第6个</td>
<td><code>%r9</code></td>
<td><code>&amp;num[3]</code> → <code>0xc(%rsp)</code></td>
</tr>
<tr>
<td>第7个</td>
<td>栈上 push</td>
<td><code>&amp;num[4]</code> → <code>0x10(%rsp)</code></td>
</tr>
<tr>
<td>第8个</td>
<td>栈上 push</td>
<td><code>&amp;num[5]</code> → <code>0x14(%rsp)</code></td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>前6个参数走寄存器，超过6个的参数通过压栈传递。</strong></p>
</blockquote>
<p>这样，一切就说得通了。执行完<code>sscanf</code>命令后，我们检查返回值<code>%eax</code>，如果小于等于5，直接爆炸。<strong>所以输入的数字一定要够6个。</strong></p>
<h3 id="phase-3：switch语句"><code>phase_3</code>：<code>switch</code>语句</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">0000000000001641 &lt;phase_3&gt;:</span><br><span class="line">    1641:	f3 0f 1e fa          	endbr64</span><br><span class="line">    1645:	48 83 ec 18          	sub    $0x18,%rsp</span><br><span class="line">    1649:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax</span><br><span class="line">    1650:	00 00 </span><br><span class="line">    1652:	48 89 44 24 08       	mov    %rax,0x8(%rsp)</span><br><span class="line">    1657:	31 c0                	xor    %eax,%eax # eax清空</span><br><span class="line">    1659:	48 8d 4c 24 04       	lea    0x4(%rsp),%rcx</span><br><span class="line">    165e:	48 89 e2             	mov    %rsp,%rdx # 栈顶放到sscanf第三入参中</span><br><span class="line">    1661:	48 8d 35 d0 1c 00 00 	lea    0x1cd0(%rip),%rsi        # 3338 &lt;array.0+0x238&gt;</span><br><span class="line">    1668:	e8 93 fc ff ff       	call   1300 &lt;__isoc99_sscanf@plt&gt;  </span><br><span class="line">    166d:	83 f8 01             	cmp    $0x1,%eax # sscanf的返回值与1比较</span><br><span class="line">    1670:	7e 1e                	jle    1690 &lt;phase_3+0x4f&gt; # lower than or equal 1 then bomb!</span><br><span class="line">    1672:	83 3c 24 07          	cmpl   $0x7,(%rsp) # 输入的首个数字和7比较</span><br><span class="line">    1676:	0f 87 9a 00 00 00    	ja     1716 &lt;phase_3+0xd5&gt; # above then bomb</span><br><span class="line">    167c:	8b 04 24             	mov    (%rsp),%eax # rsp&#x27;s value stored by rtn value</span><br><span class="line">    167f:	48 8d 15 5a 1a 00 00 	lea    0x1a5a(%rip),%rdx        # 30e0 &lt;_IO_stdin_used+0xe0&gt;</span><br><span class="line">    1686:	48 63 04 82          	movslq (%rdx,%rax,4),%rax # 符号拓展，输入的数字作为索引，乘以4（因为每个元素占4字节）加上rdx的值，得到数组中对应元素的地址，再将该地址中的值加载到rax中</span><br><span class="line">    168a:	48 01 d0             	add    %rdx,%rax </span><br><span class="line">    168d:	3e ff e0             	notrack jmp *%rax</span><br><span class="line">    1690:	e8 16 05 00 00       	call   1bab &lt;explode_bomb&gt;</span><br><span class="line">    1695:	eb db                	jmp    1672 &lt;phase_3+0x31&gt;</span><br><span class="line">    1697:	b8 c6 00 00 00       	mov    $0xc6,%eax </span><br><span class="line">    169c:	2d e7 03 00 00       	sub    $0x3e7,%eax # -999</span><br><span class="line">    16a1:	05 37 02 00 00       	add    $0x237,%eax # +567</span><br><span class="line">    16a6:	2d ad 01 00 00       	sub    $0x1ad,%eax #</span><br><span class="line">    16ab:	05 ad 01 00 00       	add    $0x1ad,%eax</span><br><span class="line">    16b0:	2d ad 01 00 00       	sub    $0x1ad,%eax</span><br><span class="line">    16b5:	05 ad 01 00 00       	add    $0x1ad,%eax</span><br><span class="line">    16ba:	2d ad 01 00 00       	sub    $0x1ad,%eax # 最后是-862</span><br><span class="line">    16bf:	83 3c 24 05          	cmpl   $0x5,(%rsp)</span><br><span class="line">    16c3:	7f 06                	jg     16cb &lt;phase_3+0x8a&gt;</span><br><span class="line">    16c5:	39 44 24 04          	cmp    %eax,0x4(%rsp)</span><br><span class="line">    16c9:	74 05                	je     16d0 &lt;phase_3+0x8f&gt;</span><br><span class="line">    16cb:	e8 db 04 00 00       	call   1bab &lt;explode_bomb&gt;</span><br><span class="line">    16d0:	48 8b 44 24 08       	mov    0x8(%rsp),%rax</span><br><span class="line">    16d5:	64 48 2b 04 25 28 00 	sub    %fs:0x28,%rax</span><br><span class="line">    16dc:	00 00 </span><br><span class="line">    16de:	75 42                	jne    1722 &lt;phase_3+0xe1&gt;</span><br><span class="line">    16e0:	48 83 c4 18          	add    $0x18,%rsp</span><br><span class="line">    16e4:	c3                   	ret</span><br><span class="line">    16e5:	b8 00 00 00 00       	mov    $0x0,%eax # 第一个输入了几 就跳转到第几个mov/jmp语句组</span><br><span class="line">    16ea:	eb b0                	jmp    169c &lt;phase_3+0x5b&gt;</span><br><span class="line">    16ec:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line">    16f1:	eb ae                	jmp    16a1 &lt;phase_3+0x60&gt;</span><br><span class="line">    16f3:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line">    16f8:	eb ac                	jmp    16a6 &lt;phase_3+0x65&gt;</span><br><span class="line">    16fa:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line">    16ff:	eb aa                	jmp    16ab &lt;phase_3+0x6a&gt;</span><br><span class="line">    1701:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line">    1706:	eb a8                	jmp    16b0 &lt;phase_3+0x6f&gt;</span><br><span class="line">    1708:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line">    170d:	eb a6                	jmp    16b5 &lt;phase_3+0x74&gt;</span><br><span class="line">    170f:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line">    1714:	eb a4                	jmp    16ba &lt;phase_3+0x79&gt;</span><br><span class="line">    1716:	e8 90 04 00 00       	call   1bab &lt;explode_bomb&gt;</span><br><span class="line">    171b:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line">    1720:	eb 9d                	jmp    16bf &lt;phase_3+0x7e&gt;</span><br><span class="line">    1722:	e8 29 fb ff ff       	call   1250 &lt;__stack_chk_fail@plt&gt;</span><br></pre></td></tr></table></figure>
<h4 id="快速解题-3">快速解题</h4>
<p>关于本题，课程文档给出的提示如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> ()</span><br><span class="line">  <span class="keyword">case</span>:</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="keyword">case</span>:</span><br><span class="line">  <span class="comment">//...</span></span><br></pre></td></tr></table></figure>
<p>这倒是给了我们灵感，我们可以在汇编代码中寻找类似<code>switch &amp; case</code>语句的逻辑。</p>
<p>首先我们发现了在上一个<code>phase</code>就出现过的<code>sscanf</code>语句，发现它的三参和四参是<code>(%rsp)</code>和<code>(%rsp) + 4</code>，除此之外没有压栈的操作，然后我们继续，看到函数返回后，首先检验<code>%eax</code>是否大于1 ，如果否，则炸弹直接爆炸。所以这或许提示我们，我们需要输入两个元素，它们被存储的地址从<code>%rsp</code>开始。</p>
<p>然后继续向下，我们发现了<code>1672</code>的<code>cmpl</code>语句和后面的<code>ja</code>，这说明第一个数字不能超过7，<strong>并且不能为负数</strong>，否则就会爆炸。这是不是很像<code>switch</code>的各种<code>case</code>和<code>default</code>？</p>
<div class="markdown-alert markdown-alert-note"><p class="markdown-alert-title"><svg class="octicon octicon-info mr-2" viewbox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z"/></svg>Note</p><p></p>
<p>为什么不能是负数，这个限定是<code>ja</code>指令规定的，下面知识补充部分会详细解释。</p>
</div>
<p>继续向下，我们发现程序将一个预留的地址放到了<code>%rdx</code>中，把首参放到了<code>%rax</code>，然后用一个表达式求出了一个地址，把这个地址放到<code>%rax</code>中，其值为<code>(SignExt(M[%rdx + 4 * %rax])) + %rdx</code>。接下来直接跳转到这个地址处。</p>
<div class="markdown-alert markdown-alert-note"><p class="markdown-alert-title"><svg class="octicon octicon-info mr-2" viewbox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z"/></svg>Note</p><p></p>
<p><code>movslq</code>命令似乎在Reference Sheet里没有特别说明，需要结合课上学到的内容来理解，实际上就是把32位数据<strong>符号拓展</strong>到64位。见下面的知识补充部分。</p>
</div>
<p>而我们不难发现，以上运算中，唯一的变数就是<code>%rax</code>，你输入的首参是多少，那么跳转的地址就有几个4字节的偏移量。</p>
<blockquote>
<p>下面以首参为1为例。</p>
</blockquote>
<p><img src="/posts/8eada4ef/image-20260221145147139.png" alt></p>
<p><img src="/posts/8eada4ef/image-20260221145539173.png" alt></p>
<p><img src="/posts/8eada4ef/image-20260221150056877.png" alt></p>
<div class="markdown-alert markdown-alert-note"><p class="markdown-alert-title"><svg class="octicon octicon-info mr-2" viewbox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z"/></svg>Note</p><p></p>
<p>你可以看到，原本存放在<code>%rdx</code>的预留地址是<code>0x5555555570e0</code>。我这里输入的首参是1，所以对应的<code>movslq</code>得到的地址中的值就是<code>0xffffe605</code>，这个结果和预留地址相加，结果是<code>0x5556555556e5</code>，就是<code>&lt;phase_3+163&gt;</code>的<code>ret</code>后第一个<code>mov</code>操作。下面每个<code>mov</code>操作后面都对应不同的跳转地址，按照我们目前的选择，就跳转到了图中这个位置。</p>
</div>
<p>按照首参正确跳转后，做了一系列加减运算，这都不重要。关键是下面两个比较语句<code>cmpl</code> <code>cmp</code>。第一个<code>cmpl</code>要检查<code>(%rsp)</code>是否大于5，如果大于就会引爆炸弹；第二个比较语句比较最后的运算结果是否与二参相等，如果相等才能退出；否则就会爆炸。</p>
<p>所以我们总结最后的逻辑如下（伪代码）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">sscanf</span>(input, <span class="string">&quot;%d %d&quot;</span>, &amp;first, &amp;second) &lt;= <span class="number">1</span>) explode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (first &gt; <span class="number">7</span>) explode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (first) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0</span>: ret_val = f0(); <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>: ret_val = f1(); <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span>: ret_val = f2(); <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">3</span>: ret_val = f3(); <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">4</span>: ret_val = f4(); <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">5</span>: ret_val = f5(); <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">6</span>: ret_val = f6(); <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">7</span>: ret_val = f7(); <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (first &gt; <span class="number">5</span>) explode;</span><br><span class="line"><span class="keyword">if</span> (second != ret_val) explode;</span><br></pre></td></tr></table></figure>
<p>而我输入的首参是1 ，对应的<code>f1()</code>的返回值是<code>-861</code>。所以最后需要输入的答案：</p>
<p><code>1 -861</code></p>
<p>解决！</p>
<h4 id="知识补充-3">知识补充</h4>
<h5 id="跳转操作">跳转操作</h5>
<p>若想搞清楚各种跳转操作，需要仔细回顾课内所学，并阅读Reference Sheet。下面我截取课件和Sheet中和跳转内容有关的内容，据此总结跳转操作的问题。</p>
<p><img src="/posts/8eada4ef/image-20260221152810935.png" alt></p>
<p><img src="/posts/8eada4ef/image-20260221160834469.png" alt></p>
<p><img src="/posts/8eada4ef/image-20260221160810821.png" alt></p>
<p><img src="/posts/8eada4ef/image-20260221160858345.png" alt></p>
<p><img src="/posts/8eada4ef/image-20260221160910822.png" alt></p>
<h6 id="条件码-Condition-Codes">条件码 Condition Codes</h6>
<div class="markdown-alert markdown-alert-note"><p class="markdown-alert-title"><svg class="octicon octicon-info mr-2" viewbox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z"/></svg>Note</p><p></p>
<p>以下解释仅仅针对的是加减法，关于乘除的原理，要复杂得多，在计算机组成课程中会对乘除法的硬件原理进行部分讲解。</p>
</div>
<ul>
<li><code>CF</code>：进位标志，针对无符号数运算设置的；无符号数加减法超过表示范围就会产生进位/借位，此时标志位就会被设置（为1）；</li>
<li><code>SF</code>：符号标志，为符号数运算设置的；如果符号数运算后，结果的符号位是1 。</li>
<li><code>ZF</code>：零标志，如果运算结果为0，则设置为1；</li>
<li><code>OF</code>：溢出标志，为符号数运算设置；设加法的两个运算数的符号位是<code>w</code>和<code>y</code>（减法在硬件层面最后也被转化成加法，所以实际是一样的东西；且实际上符号数的减法得到结果永远不可能发生溢出），结果符号位是<code>z</code>：
<ul>
<li><code>w</code> <code>y</code>同正，得到负数，说明超出表示范围，<code>w != z</code>，set <code>OF</code>；</li>
<li><code>w</code> <code>y</code>同负，得到正数，说明超出表示范围，<code>w != z</code>，set <code>OF</code>；</li>
</ul>
</li>
</ul>
<h6 id="跳转操作分类">跳转操作分类</h6>
<p><img src="/posts/8eada4ef/image-20260221160244412.png" alt></p>
<p><img src="/posts/8eada4ef/image-20260221152745476.png" alt></p>
<p>从上面的图中，我们可以看到，不同的跳转命令针对的运算类型都不一样，本题中涉及到的命令是<code>ja</code>，那么对应的设置条件就是<code>~CF&amp;~ZF</code>，那么就是将两个内存单位的数据都当成<strong>无符号数</strong>进行运算，<strong>不发生进位</strong>，且<strong>结果不为0</strong>。所以如果我的首参是一个负数，则符号位会被看成最高位，它会被看成一个巨大正数，自然是大于7的数了，所以会触发“爆炸”。</p>
<h5 id="movslq"><code>movslq</code></h5>
<p>这个命令可以被拆解为三个部分，分别是<code>mov</code> <code>s</code> <code>lq</code>。</p>
<ul>
<li><code>mov</code>是复制操作；</li>
<li><code>s</code>是<strong>sign-extend（符号拓展）的意思</strong>，也就是在拓展的时候，填充的位要和符号位保持一致；与之相反的是<code>z</code>（<strong>zero-extend，零拓展</strong>）；</li>
<li><code>lq</code>：意思是从<code>l</code>到<code>q</code>，就是说从32位到64位。下面说明数据类型后缀的具体含义。
<ul>
<li><code>b</code>：Byte，8位；</li>
<li><code>w</code>：Word，1字约定俗成为2B，所以是16位；</li>
<li><code>l</code>：Long，<code>long</code>类型数据占用32位（如C语言）；</li>
<li><code>q</code>：Quad，4字的意思，也就是64位。</li>
</ul>
</li>
</ul>
<h3 id="phase-4：递归函数"><code>phase_4</code>：递归函数</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">0000000000001727 &lt;func4&gt;:</span><br><span class="line">    1727:	f3 0f 1e fa          	endbr64 # edi 5 esi argu2</span><br><span class="line">    172b:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line">    1730:	85 ff                	test   %edi,%edi # 5&amp;5</span><br><span class="line">    1732:	7e 2d                	jle    1761 &lt;func4+0x3a&gt; # if param1 &amp; param1 &lt;= 0, ret; else continue. </span><br><span class="line">    1734:	41 54                	push   %r12</span><br><span class="line">    1736:	55                   	push   %rbp</span><br><span class="line">    1737:	53                   	push   %rbx</span><br><span class="line">    1738:	89 fb                	mov    %edi,%ebx # ebx=5</span><br><span class="line">    173a:	89 f5                	mov    %esi,%ebp # ebp=argu2</span><br><span class="line">    173c:	89 f0                	mov    %esi,%eax # rtn=argu2</span><br><span class="line">    173e:	83 ff 01             	cmp    $0x1,%edi # 若何时edi为1直接跳出</span><br><span class="line">    1741:	74 19                	je     175c &lt;func4+0x35&gt;</span><br><span class="line">    1743:	8d 7f ff             	lea    -0x1(%rdi),%edi # 因为本来edi存的值就是5，因此这个的意思就是直接-1</span><br><span class="line">    1746:	e8 dc ff ff ff       	call   1727 &lt;func4&gt;</span><br><span class="line">    174b:	44 8d 24 28          	lea    (%rax,%rbp,1),%r12d # rax=argu2 rbp=argu2</span><br><span class="line">    174f:	8d 7b fe             	lea    -0x2(%rbx),%edi # rbx=5 每次减去2</span><br><span class="line">    1752:	89 ee                	mov    %ebp,%esi # argu2传入esi</span><br><span class="line">    1754:	e8 ce ff ff ff       	call   1727 &lt;func4&gt;</span><br><span class="line">    1759:	44 01 e0             	add    %r12d,%eax</span><br><span class="line">    175c:	5b                   	pop    %rbx</span><br><span class="line">    175d:	5d                   	pop    %rbp</span><br><span class="line">    175e:	41 5c                	pop    %r12</span><br><span class="line">    1760:	c3                   	ret</span><br><span class="line">    1761:	c3                   	ret</span><br><span class="line"></span><br><span class="line">0000000000001762 &lt;phase_4&gt;:</span><br><span class="line">    1762:	f3 0f 1e fa          	endbr64</span><br><span class="line">    1766:	48 83 ec 18          	sub    $0x18,%rsp</span><br><span class="line">    176a:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax</span><br><span class="line">    1771:	00 00 </span><br><span class="line">    1773:	48 89 44 24 08       	mov    %rax,0x8(%rsp)</span><br><span class="line">    1778:	31 c0                	xor    %eax,%eax</span><br><span class="line">    177a:	48 89 e1             	mov    %rsp,%rcx</span><br><span class="line">    177d:	48 8d 54 24 04       	lea    0x4(%rsp),%rdx</span><br><span class="line">    1782:	48 8d 35 af 1b 00 00 	lea    0x1baf(%rip),%rsi        # 3338 &lt;array.0+0x238&gt;</span><br><span class="line">    1789:	e8 72 fb ff ff       	call   1300 &lt;__isoc99_sscanf@plt&gt;</span><br><span class="line">    178e:	83 f8 02             	cmp    $0x2,%eax</span><br><span class="line">    1791:	75 0b                	jne    179e &lt;phase_4+0x3c&gt; # 一定相等 不然爆炸（输入两个数字）</span><br><span class="line">    1793:	8b 04 24             	mov    (%rsp),%eax # argu2 转移到eax</span><br><span class="line">    1796:	83 e8 02             	sub    $0x2,%eax # argu2 - 2</span><br><span class="line">    1799:	83 f8 02             	cmp    $0x2,%eax # argu2-2 与 2比较</span><br><span class="line">    179c:	76 05                	jbe    17a3 &lt;phase_4+0x41&gt; # 如果argu2-2大于2 就爆炸</span><br><span class="line">    179e:	e8 08 04 00 00       	call   1bab &lt;explode_bomb&gt;</span><br><span class="line">    17a3:	8b 34 24             	mov    (%rsp),%esi # argu2继续给esi</span><br><span class="line">    17a6:	bf 05 00 00 00       	mov    $0x5,%edi # 5给edi</span><br><span class="line">    17ab:	e8 77 ff ff ff       	call   1727 &lt;func4&gt;</span><br><span class="line">    17b0:	39 44 24 04          	cmp    %eax,0x4(%rsp) # 以5 argu2为参数的返回值 将argu1与返回值比较</span><br><span class="line">    17b4:	75 15                	jne    17cb &lt;phase_4+0x69&gt; # 如果不相等就会爆炸</span><br><span class="line">    17b6:	48 8b 44 24 08       	mov    0x8(%rsp),%rax # 某种还原操作</span><br><span class="line">    17bb:	64 48 2b 04 25 28 00 	sub    %fs:0x28,%rax</span><br><span class="line">    17c2:	00 00 </span><br><span class="line">    17c4:	75 0c                	jne    17d2 &lt;phase_4+0x70&gt;</span><br><span class="line">    17c6:	48 83 c4 18          	add    $0x18,%rsp</span><br><span class="line">    17ca:	c3                   	ret</span><br><span class="line">    17cb:	e8 db 03 00 00       	call   1bab &lt;explode_bomb&gt;</span><br><span class="line">    17d0:	eb e4                	jmp    17b6 &lt;phase_4+0x54&gt;</span><br><span class="line">    17d2:	e8 79 fa ff ff       	call   1250 &lt;__stack_chk_fail@plt&gt;</span><br></pre></td></tr></table></figure>
<h4 id="快速解题-4">快速解题</h4>
<p>文档中关于此题给出的关键词是**“递归”**，所以我们可以尝试从这段代码中寻找某个类似于递归函数演进的逻辑，并试着写出它的函数表达式/代码。一旦我们搞清楚了这个递归函数的逻辑，并且找到了初始的入参，就能解决这个问题。</p>
<p>在我看来解决这个问题不一定需要用到调试器，自己用笔写写画画可能是更简单的方法。</p>
<h5 id="主框架：phase-5">主框架：<code>phase_5</code></h5>
<p><code>phase_5</code>的整体逻辑还是相对易懂的。我们下面分步阐述它的逻辑。</p>
<ol>
<li>
<p>使用<code>sscanf</code>在<code>%rsp + 4</code>和<code>%rsp</code>处存入<strong>首参</strong>x和<strong>二参</strong>y，并且通过对返回值的检查限定输入的变量数只能为2 。（from <code>1778</code> to <code>1791</code>）</p>
</li>
<li>
<p><code>if (y - 2 &gt; 2) or (y - 2 &lt; 0): explode_bomb()</code>；（from <code>1793</code> to <code>179e</code>）</p>
<div class="markdown-alert markdown-alert-caution"><p class="markdown-alert-title"><svg class="octicon octicon-stop mr-2" viewbox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="M4.47.22A.749.749 0 0 1 5 0h6c.199 0 .389.079.53.22l4.25 4.25c.141.14.22.331.22.53v6a.749.749 0 0 1-.22.53l-4.25 4.25A.749.749 0 0 1 11 16H5a.749.749 0 0 1-.53-.22L.22 11.53A.749.749 0 0 1 0 11V5c0-.199.079-.389.22-.53Zm.84 1.28L1.5 5.31v5.38l3.81 3.81h5.38l3.81-3.81V5.31L10.69 1.5ZM8 4a.75.75 0 0 1 .75.75v3.5a.75.75 0 0 1-1.5 0v-3.5A.75.75 0 0 1 8 4Zm0 8a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z"/></svg>Caution</p><p></p>
<p>因为<code>jbe</code>是无符号数比较，所以负数会被看成一个巨大的正数。</p>
</div>
</li>
<li>
<p>调用<code>func4</code>函数，传参情况为<code>func4(5, y)</code>；（from <code>17a3</code> to <code>17ab</code>）</p>
</li>
<li>
<p><code>if x == func4(5, y): return; else explode_bomb()</code>。</p>
</li>
</ol>
<p>可以看到，主框架里唯一和递归函数可能沾边的就是这个<code>func4</code>，所以接下来要分析它的逻辑。</p>
<h5 id="递归函数：func4">递归函数：<code>func4</code></h5>
<p>我们假设传入该函数的两个参数为x和y，以下分步阐述其逻辑。</p>
<ol>
<li><code>if x &lt;= 0: return 0</code>（<code>172b</code> ~ <code>1732</code>）；</li>
<li><code>else if x == 1 : return y</code>（<code>1734</code> ~ <code>1741</code>）；</li>
<li><code>var z = f(x - 1, y) + y</code>（<code>1743</code> ~ <code>174b</code>）；</li>
<li><code>return z + f(x - 2, y)</code>（<code>174f</code> ~ <code>1760</code>）</li>
</ol>
<p>这是一个很典型的递归函数的结构：<strong>先定义递归出口（遇到特定情况结束递归），然后定义递归逻辑</strong>。</p>
<h5 id="总体结构">总体结构</h5>
<p>通过以上的分析，可以尝试写出一个完整的函数逻辑。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">func4</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (x &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (x == <span class="number">1</span>) <span class="keyword">return</span> y;</span><br><span class="line">  <span class="keyword">return</span> f(x - <span class="number">1</span>, y) + y + f(x - <span class="number">2</span>, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">phase_4</span><span class="params">(<span class="type">char</span>* input)</span>&#123;</span><br><span class="line">  <span class="type">int</span> x, y;</span><br><span class="line">  <span class="type">int</span> input_num = <span class="built_in">sscanf</span>(input, <span class="string">&quot;%d %d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">  <span class="keyword">if</span> (input_num != <span class="number">2</span>)&#123;</span><br><span class="line">    explode_bomb();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (y - <span class="number">2</span> &gt; <span class="number">2</span> || y - <span class="number">2</span> &lt; <span class="number">0</span>) explode_bomb();</span><br><span class="line">  <span class="keyword">if</span> (func4(<span class="number">5</span>, y) != x) explode_bomb();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以，我们如果传入二参<code>4</code>，那么经过计算，<code>func4(5, 4)</code>的值为48 ，所以首参需要填48，也就是<code>48 4</code>。</p>
<h3 id="phase-5：用输入字符串访问数组"><code>phase_5</code>：用输入字符串访问数组</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">00000000000017d7 &lt;phase_5&gt;:</span><br><span class="line">    17d7:	f3 0f 1e fa          	endbr64</span><br><span class="line">    17db:	53                   	push   %rbx</span><br><span class="line">    17dc:	48 89 fb             	mov    %rdi,%rbx # 输入的字符串存储在rdi中</span><br><span class="line">    17df:	e8 92 02 00 00       	call   1a76 &lt;string_length&gt;</span><br><span class="line">    17e4:	83 f8 06             	cmp    $0x6,%eax # 限定字符串长度为6</span><br><span class="line">    17e7:	75 2c                	jne    1815 &lt;phase_5+0x3e&gt;</span><br><span class="line">    17e9:	48 89 d8             	mov    %rbx,%rax</span><br><span class="line">    17ec:	48 8d 7b 06          	lea    0x6(%rbx),%rdi # 将字符串结尾后的首地址传入rdi中，当指针到达此处意味着已按字节遍历完字符串</span><br><span class="line">    17f0:	b9 00 00 00 00       	mov    $0x0,%ecx</span><br><span class="line">    17f5:	48 8d 35 04 19 00 00 	lea    0x1904(%rip),%rsi        # 3100 &lt;array.0&gt;</span><br><span class="line">    17fc:	0f b6 10             	movzbl (%rax),%edx # 字符串的第一个字符的ASCII码送进edx</span><br><span class="line">    17ff:	83 e2 0f             	and    $0xf,%edx # 原本ascii八位，取后四位，正好是数字本身。                                          </span><br><span class="line">    1802:	03 0c 96             	add    (%rsi,%rdx,4),%ecx # 取数组特定索引处的元素值</span><br><span class="line">    1805:	48 83 c0 01          	add    $0x1,%rax # iter++</span><br><span class="line">    1809:	48 39 f8             	cmp    %rdi,%rax # 地址是否相同，即是否已遍历完数组。</span><br><span class="line">    180c:	75 ee                	jne    17fc &lt;phase_5+0x25&gt;</span><br><span class="line">    180e:	83 f9 2e             	cmp    $0x2e,%ecx </span><br><span class="line">    1811:	75 09                	jne    181c &lt;phase_5+0x45&gt;</span><br><span class="line">    1813:	5b                   	pop    %rbx</span><br><span class="line">    1814:	c3                   	ret</span><br><span class="line">    1815:	e8 91 03 00 00       	call   1bab &lt;explode_bomb&gt;</span><br><span class="line">    181a:	eb cd                	jmp    17e9 &lt;phase_5+0x12&gt;</span><br><span class="line">    181c:	e8 8a 03 00 00       	call   1bab &lt;explode_bomb&gt;</span><br><span class="line">    1821:	eb f0                	jmp    1813 &lt;phase_5+0x3c&gt;</span><br><span class="line">    # ......</span><br><span class="line">    </span><br><span class="line">0000000000001a76 &lt;string_length&gt;:</span><br><span class="line">    1a76:	f3 0f 1e fa          	endbr64</span><br><span class="line">    1a7a:	80 3f 00             	cmpb   $0x0,(%rdi)</span><br><span class="line">    1a7d:	74 12                	je     1a91 &lt;string_length+0x1b&gt;</span><br><span class="line">    1a7f:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line">    1a84:	48 83 c7 01          	add    $0x1,%rdi</span><br><span class="line">    1a88:	83 c0 01             	add    $0x1,%eax</span><br><span class="line">    1a8b:	80 3f 00             	cmpb   $0x0,(%rdi)</span><br><span class="line">    1a8e:	75 f4                	jne    1a84 &lt;string_length+0xe&gt;</span><br><span class="line">    1a90:	c3                   	ret</span><br><span class="line">    1a91:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line">    1a96:	c3                   	ret</span><br></pre></td></tr></table></figure>
<h4 id="快速解题-5">快速解题</h4>
<p>实验文档对这一阶段给出的提示为，“请关注你的输入和<code>array</code>的转换关系”，那么我们就要从此入手，分析<code>array</code>在哪里，以及分析输入以何种模式来处理这个数组。</p>
<p>从开头的函数<code>string_length</code>我们就能判断出，这次我们需要输入的变量只有一个<strong>字符串</strong>，并且其<strong>长度是6</strong> 。然后我们从<code>17f5</code>处代码自带的注释<code># 3100 &lt;array.0&gt;</code>可以猜测出，放到<code>%rsi</code>中存储的有可能是<strong>和数组<code>array</code>有关的一个地址</strong>。</p>
<p>而接下来的两行是对输入字符串当前索引处的字符<code>ASCII</code>码取低4位，而巧合的是，由<code>ASCII</code>码对照表（部分如下图）我们可以观察到，数字<code>0</code>~<code>9</code>的<code>ASCII</code>码低四位恰好是其数字本身的二进制表示，所以这有可能是一个<strong>将<code>char</code>型字符转化成对应整型数字的操作</strong>。</p>
<div class="markdown-alert markdown-alert-note"><p class="markdown-alert-title"><svg class="octicon octicon-info mr-2" viewbox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z"/></svg>Note</p><p></p>
<p>当然你可以选取任何字符，只要最后截取后四位得到的值能满足题目要求即可。但是选数字是最直观的。</p>
</div>
<p><img src="/posts/8eada4ef/image-20260226004833338.png" alt></p>
<p>而下面这一条指令<code>add    (%rsi,%rdx,4),%ecx</code>，则有点像是 <strong>以当前处理的字符对应的索引（或说偏移量）访问数组元素，并将其累加到某个变量中（<code>%ecx</code>）</strong> 的操作。所以我们通过GDB验证一下：</p>
<p><img src="/posts/8eada4ef/image-20260226010055039.png" alt></p>
<p>原来真的是每隔四个字节存放一个元素，按照<code>x86-64</code>中<code>int</code>占4字节的惯例，我们合理怀疑<code>%rsi</code>存放了一个整型数组的起始地址。经过调试，可以得出数组的构成如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="built_in">array</span>[<span class="number">16</span>] = &#123;<span class="number">2</span>, <span class="number">10</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">12</span>, <span class="number">16</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">14</span>, <span class="number">5</span>, <span class="number">11</span>, <span class="number">8</span>, <span class="number">15</span>, <span class="number">13</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>正好对应低四位共<code>16</code>种二进制码。</p>
<p>当累加完当前的数组元素后，<code>%rax</code>像指针一样，递增1字节，指向字符串的第二个字符。而由于<code>%rdi</code>的值已经被提前设置为<strong>输入字符串的起始地址向后偏移6字节</strong>，我们可以得出，<code>cmp    %rdi,%rax</code>（<code>1809</code>）这条指令实际上是判断是否已经遍历完输入的六个字符。在遍历完之后，我们将<code>%ecx</code>的值和<code>0x2e</code>（十进制<code>46</code>）做比较，相等则拆弹成功。</p>
<p>所以观察数组，只要选出的六个元素（可重复）之和为46 ，就可以拆弹。一个可能的答案为<code>444200</code>（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>12</mn><mo>+</mo><mn>12</mn><mo>+</mo><mn>12</mn><mo>+</mo><mn>6</mn><mo>+</mo><mn>2</mn><mo>+</mo><mn>2</mn><mo>=</mo><mn>46</mn></mrow><annotation encoding="application/x-tex">12+12+12+6+2+2=46</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">12</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">12</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">12</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">6</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">46</span></span></span></span>）。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://ziyuliu258.github.io">Derrick Liu</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://ziyuliu258.github.io/posts/8eada4ef/">https://ziyuliu258.github.io/posts/8eada4ef/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://ziyuliu258.github.io" target="_blank">日拱一卒</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/ICS%E5%AE%9E%E9%AA%8C/">ICS实验</a></div><div class="post-share"><div class="social-share" data-image="/images/avatar.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/posts/e26699b7/" title="XJTU-ICS Lab 1: Data Lab"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2026-01-14</div><div class="info-item-2">XJTU-ICS Lab 1: Data Lab</div></div><div class="info-2"><div class="info-item-1">前言 实验文档与代码框架 本文档是参照笔者在sp25所选的西安交通大学计算机系统导论课程与配套实验内容而写成的，参考教材就是大名鼎鼎的CSAPP。至今课程网站仍然可以访问（如果不是校园网连接，可能需要科学上网技术），实验文档、课程PPT、部分代码框架也均可以在上面找到。有兴趣的读者可以自行了解更多内容。 实验1的代码框架是一致的，都可以从这一仓库获取，直接git clone即可。 默认前提 本文默认读者已经掌握以下知识/技巧：  能够熟练地掌握C语言的基本语法； 有较好的数据结构知识基础； 能够较为熟练地使用Git、make等工具链； 对Linux命令行的基本操作较为熟悉。  但是如果你此时仍然没有掌握以上提到的基本知识，那也没有关系，不会影响完成这个实验。但是为了更好地了解你的电脑，便利你此后的学习之路，你可以尝试学习一下MIT的课程The Missing Semester of Your CS...</div></div></div></a><a class="pagination-related" href="/posts/723210bf/" title="与make命令的初邂逅"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-02-28</div><div class="info-item-2">与make命令的初邂逅</div></div><div class="info-2"><div class="info-item-1"> 前情提要（偏题）：开学第一周费尽周折选上了学校的ICS（计算机系统导论） 课。此课无比硬核，以著名神书 《CSAPP》...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/images/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Derrick Liu</div><div class="author-info-description">An undergraduate majoring in CS.</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">13</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">7</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/ziyuliu258"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/ziyuliu258" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:1209830516abc@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">昼短苦夜长，何不秉烛游？</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E6%96%87%E6%A1%A3%E4%B8%8E%E4%BB%A3%E7%A0%81%E6%A1%86%E6%9E%B6"><span class="toc-number">1.1.</span> <span class="toc-text">实验文档与代码框架</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%88%99"><span class="toc-number">1.2.</span> <span class="toc-text">原则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%AC%E6%96%87%E7%9A%84%E4%BE%A7%E9%87%8D%E7%82%B9"><span class="toc-number">1.3.</span> <span class="toc-text">本文的侧重点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.4.</span> <span class="toc-text">参考实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E5%86%85%E5%AE%B9%E4%B8%8E%E5%9F%BA%E6%9C%AC%E8%A6%81%E6%B1%82"><span class="toc-number">2.</span> <span class="toc-text">实验内容与基本要求</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%BB%E5%8A%A1"><span class="toc-number">2.1.</span> <span class="toc-text">基本任务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">2.2.</span> <span class="toc-text">注意事项</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BE%85%E5%8A%A9%E5%86%85%E5%AE%B9"><span class="toc-number">3.</span> <span class="toc-text">辅助内容</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9A%A0%EF%B8%8FCS107-x86-64-Reference-Sheet"><span class="toc-number">3.1.</span> <span class="toc-text">⚠️CS107 x86-64 Reference Sheet</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ASCII%E7%A0%81%E5%AF%B9%E7%85%A7%E8%A1%A8"><span class="toc-number">3.2.</span> <span class="toc-text">ASCII码对照表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GDB%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="toc-number">3.3.</span> <span class="toc-text">GDB常用命令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E5%BC%80%E5%A7%8B%EF%BC%9F"><span class="toc-number">3.3.1.</span> <span class="toc-text">怎么开始？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%A5%E8%BF%9B-%E6%AD%A5%E8%BF%87"><span class="toc-number">3.3.2.</span> <span class="toc-text">步进&#x2F;步过</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%82%E5%AF%9F%E4%B8%8D%E5%90%8C%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%80%BC"><span class="toc-number">3.3.3.</span> <span class="toc-text">观察不同类型的值</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#x%E6%93%8D%E4%BD%9C"><span class="toc-number">3.3.3.1.</span> <span class="toc-text">x操作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#p%E6%93%8D%E4%BD%9C"><span class="toc-number">3.3.3.2.</span> <span class="toc-text">p操作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#display%E5%91%BD%E4%BB%A4"><span class="toc-number">3.3.3.3.</span> <span class="toc-text">display命令</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8%E4%BF%A1%E6%81%AF%E6%9F%A5%E8%AF%A2"><span class="toc-number">3.3.3.4.</span> <span class="toc-text">寄存器信息查询</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%80%92%E9%80%80%E6%93%8D%E4%BD%9C"><span class="toc-number">3.3.4.</span> <span class="toc-text">倒退操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%9A%A0%EF%B8%8FTUI%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.3.5.</span> <span class="toc-text">⚠️TUI模式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E8%A7%A3"><span class="toc-number">4.</span> <span class="toc-text">题解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BA%90%E4%BB%A3%E7%A0%81"><span class="toc-number">4.1.</span> <span class="toc-text">源代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B1%87%E7%BC%96%E4%BB%A3%E7%A0%81"><span class="toc-number">4.2.</span> <span class="toc-text">汇编代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#phase-1%EF%BC%9A%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%AF%94%E8%BE%83"><span class="toc-number">4.3.</span> <span class="toc-text">phase_1：字符串比较</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E8%A7%A3%E9%A2%98"><span class="toc-number">4.3.1.</span> <span class="toc-text">快速解题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%99%85%E6%93%8D%E4%BD%9C"><span class="toc-number">4.3.2.</span> <span class="toc-text">实际操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E8%A1%A5%E5%85%85"><span class="toc-number">4.3.3.</span> <span class="toc-text">知识补充</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#phase-2%EF%BC%9A%E6%95%B0%E5%88%97%E6%89%BE%E8%A7%84%E5%BE%8B"><span class="toc-number">4.4.</span> <span class="toc-text">phase_2：数列找规律</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E8%A7%A3%E9%A2%98-2"><span class="toc-number">4.4.1.</span> <span class="toc-text">快速解题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E8%A1%A5%E5%85%85-2"><span class="toc-number">4.4.2.</span> <span class="toc-text">知识补充</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#read-six-numbers%E8%A7%A3%E6%9E%90"><span class="toc-number">4.4.2.1.</span> <span class="toc-text">read_six_numbers解析</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#phase-3%EF%BC%9Aswitch%E8%AF%AD%E5%8F%A5"><span class="toc-number">4.5.</span> <span class="toc-text">phase_3：switch语句</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E8%A7%A3%E9%A2%98-3"><span class="toc-number">4.5.1.</span> <span class="toc-text">快速解题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E8%A1%A5%E5%85%85-3"><span class="toc-number">4.5.2.</span> <span class="toc-text">知识补充</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%B7%B3%E8%BD%AC%E6%93%8D%E4%BD%9C"><span class="toc-number">4.5.2.1.</span> <span class="toc-text">跳转操作</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E7%A0%81-Condition-Codes"><span class="toc-number">4.5.2.1.1.</span> <span class="toc-text">条件码 Condition Codes</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%B7%B3%E8%BD%AC%E6%93%8D%E4%BD%9C%E5%88%86%E7%B1%BB"><span class="toc-number">4.5.2.1.2.</span> <span class="toc-text">跳转操作分类</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#movslq"><span class="toc-number">4.5.2.2.</span> <span class="toc-text">movslq</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#phase-4%EF%BC%9A%E9%80%92%E5%BD%92%E5%87%BD%E6%95%B0"><span class="toc-number">4.6.</span> <span class="toc-text">phase_4：递归函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E8%A7%A3%E9%A2%98-4"><span class="toc-number">4.6.1.</span> <span class="toc-text">快速解题</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BB%E6%A1%86%E6%9E%B6%EF%BC%9Aphase-5"><span class="toc-number">4.6.1.1.</span> <span class="toc-text">主框架：phase_5</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E5%87%BD%E6%95%B0%EF%BC%9Afunc4"><span class="toc-number">4.6.1.2.</span> <span class="toc-text">递归函数：func4</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%BB%E4%BD%93%E7%BB%93%E6%9E%84"><span class="toc-number">4.6.1.3.</span> <span class="toc-text">总体结构</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#phase-5%EF%BC%9A%E7%94%A8%E8%BE%93%E5%85%A5%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%AE%BF%E9%97%AE%E6%95%B0%E7%BB%84"><span class="toc-number">4.7.</span> <span class="toc-text">phase_5：用输入字符串访问数组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E8%A7%A3%E9%A2%98-5"><span class="toc-number">4.7.1.</span> <span class="toc-text">快速解题</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-post-series"><div class="item-headline"><i class="fa-solid fa-layer-group"></i><span>系列文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/8eada4ef/" title="XJTU-ICS Lab 2: Bomb Lab">XJTU-ICS Lab 2: Bomb Lab</a><time datetime="2026-02-18T08:54:45.000Z" title="发表于 2026-02-18 16:54:45">2026-02-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/e26699b7/" title="XJTU-ICS Lab 1: Data Lab">XJTU-ICS Lab 1: Data Lab</a><time datetime="2026-01-14T12:48:52.000Z" title="发表于 2026-01-14 20:48:52">2026-01-14</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/723210bf/" title="与make命令的初邂逅">与make命令的初邂逅</a><time datetime="2025-02-27T17:42:17.000Z" title="发表于 2025-02-28 01:42:17">2025-02-28</time></div></div></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/38bfdd33/" title="Linux下修复三模客制化机械键盘F系列键的失灵">Linux下修复三模客制化机械键盘F系列键的失灵</a><time datetime="2026-02-24T16:39:16.000Z" title="发表于 2026-02-25 00:39:16">2026-02-25</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/d94c72e4/" title="Git分支操作：利用新分支备份状态，实现多分支版本管理">Git分支操作：利用新分支备份状态，实现多分支版本管理</a><time datetime="2026-02-24T16:17:36.000Z" title="发表于 2026-02-25 00:17:36">2026-02-25</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/8eada4ef/" title="XJTU-ICS Lab 2: Bomb Lab">XJTU-ICS Lab 2: Bomb Lab</a><time datetime="2026-02-18T08:54:45.000Z" title="发表于 2026-02-18 16:54:45">2026-02-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/e26699b7/" title="XJTU-ICS Lab 1: Data Lab">XJTU-ICS Lab 1: Data Lab</a><time datetime="2026-01-14T12:48:52.000Z" title="发表于 2026-01-14 20:48:52">2026-01-14</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/ffcd24f1/" title="维护日志">维护日志</a><time datetime="2026-01-14T12:24:41.000Z" title="发表于 2026-01-14 20:24:41">2026-01-14</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/images/bg2.jpg);"><div id="footer-wrap"><div class="copyright">&copy;2023 - 2026 By Derrick Liu</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><div class="js-pjax"><script>(async () => {
  const showKatex = () => {
    document.querySelectorAll('#article-container .katex').forEach(el => el.classList.add('katex-show'))
  }

  if (!window.katex_js_css) {
    window.katex_js_css = true
    await btf.getCSS('https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css')
    if (true) {
      await btf.getScript('https://cdn.jsdelivr.net/npm/katex/dist/contrib/copy-tex.min.js')
    }
  }

  showKatex()
})()</script></div><div class="aplayer no-destroy" data-id="13273018321" data-server="netease" data-type="playlist" data-fixed="true" data-autoplay="true" data-mini="true" data-theme="#3F51B5"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script>(() => {
  const destroyAplayer = () => {
    if (window.aplayers) {
      for (let i = 0; i < window.aplayers.length; i++) {
        if (!window.aplayers[i].options.fixed) {
          window.aplayers[i].destroy()
        }
      }
    }
  }

  const runMetingJS = () => {
    typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()
  }

  btf.addGlobalFn('pjaxSend', destroyAplayer, 'destroyAplayer')
  btf.addGlobalFn('pjaxComplete', loadMeting, 'runMetingJS')
})()</script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>(() => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => fn())
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      pjax.loadUrl('/404.html')
    }
  })
})()</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>